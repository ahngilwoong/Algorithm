/*

드디어 성공했다!!!!
드디어 성공했다!!!!
드디어 성공했다!!!!
드디어 성공했다!!!!
드디어 성공했다!!!!
드디어 성공했다!!!!
드디어 성공했다!!!!
드디어 성공했다!!!!

앞서 푼 것들에 중에 간과한것 들

1.
수식의 계산을 나눠주는 가변배열을 2개나 쓰고 인덱스를 조작해서 오류가 터질수밖에 없었다 => String 가변배열 하나로 모두 담았다.
배열 하나로 쓰고 앞 뒤 본인 인덱스를 지워주고 계산을 해주니 오류 날 일이 없다.

2.
내가 연산자가 나올 모든 경우의 수를 담은 cal 문자열 배열안의 인덱스를
String[] cal = {"-+*","+*-","+-*","-+*","-*+","*-+"}; 로 하였다. 자세히 보면 -+*가 두번있고 있어야 될 *+-가 없다.
문제의 연산자가 3가지이므로 3가지로 나올 모든 경우의 수 3! = 6가지의 조합인데 하나를 잘못쓴것이다. 순열로 정직하게 풀었으면 이런일이 없었다.
앞서 올려둔 (실패3)을 보고 한참 고민하다 발견한 것이다...


[문제 설명]

IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.
이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.
해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.
단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.
만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.

예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.

"100-200*300-500+20"

일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * > +,- 로 우선순위가 정의되어 있습니다.
대회 규칙에 따라 + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.
수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + > - > * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.
반면에 * > + > - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.

참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.

[제한사항]

expression은 길이가 3 이상 100 이하인 문자열입니다.
expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.
즉, "402+-561*"처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.
expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.
즉, "100-2145*458+12"처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.
"-56+100"처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.
expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.
연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.
같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.

[입출력 예]
expression             result
"100-200*300-500+20"   60420
"50*6-3*2"             300



즉 3가지 또는 2가지 연산자의 우선순위를 임의로 설정 절댓값으로 큰 숫자가 나오는 값을 리턴하라 이다.

일단 테스트케이스 문자열 
"100-200*300-500+20"을 
연산자와 숫자를 나눠서 String 가변배열 ar에 집어넣었다.
그리고 연산자가 나올수 있는 모든 경우의수를 cal배열안에 넣어줬다. 3!=6 총 6가지의 경우의 수가 나와 순열을 안쓰고 그냥 배열에 넣어줬다.
그 뒤 가변배열 cl을 하나 더 만들어서 가변배열 ar을 복사해줬다. (뒤에 나올 ar이 변경된 뒤 원래 값으로 돌아오게 하기 위해)
그 뒤 연산자의 모든 경우의 수가 담겨있는 cal배열만큼 반복문을 돌리고 flag함수를 총 3번 호출한다.
3번의 호출동안 CharacterAt 0 1 2 가 매개변수로 담기는데 내가 정한 우선순위로 인한 모든 값을 계산하기 위해 이렇게 해줬다.
cal index 0번째는 -+* 임으로 charAt 0 = '-' charAt 1 = '+' charAt 2 = '*' 이런 식으로 cal에 담겨있는 우선순위 연산자대로 계산되는 것이다
이제 charAt에서 나온 연산자 그리고 연산자와 숫자가 저장된 ar이라는 가변배열을 매개변수로 받는 flag함수를 3번 호출한다.
flag함수는 일단 charAt에서 나온 계산할 연산자가 ar배열에 안담겨있으면 ar을 그대로 리턴시킨다. (cal배열 연산자 중 식에 없는 연산자가 나올 경우를 방지)
그 뒤 정수 i를 0으로 초기화 해준뒤 i가 증가하는 무한 반복을 넣는다.
이 반복문은 식이 담겨있는 ar 가변배열을 하나씩 돌게되는데 이 중 ar.get(i)가 아까 앞서 매개변수로 받은 연산자와 만나게된다면
*의경우 -의경우 +의 경우에 따라 계산이 되고 계산된 인덱스는 삭제되고 그 인덱스 자리에 계산된 값이 들어가게 된다.
예를 들어 200, *, 300 이라면 *를 만나게 되었을 때 60,000이 되고 200과 *와 300은 삭제되고 그 자리에 60,000이라는 숫자가 ar 가변배열에 들어가게 되는 것이다. 
그 뒤 i--가 되어 다시 6만부터 연산자 검사를 시작하게 되고 매개변수로 받은 charAt 연산자가 다 계산 될때까지 반복되는 것이다. 그러고 i가 ar배열의 크기만큼 오게되면 break로
무한 반복을 탈출시키고 그 후 가변배열 ar을 리턴하게 된다. 
이렇게 되면 내가 정한대로 *부터 계산이 싹 되고 그 뒤 -가 싹 되고 +가 싹되고 이런 그림이 가능해진다.
이런 식으로 cal배열 안에 있는 우선순위의 식대로 계산이 전부되고 그 결과 값들이 ans라는 가변배열에 담기게 된다. 담기는 과정중 Math.abs를 통해 절대값으로 넣게 되고 
그 후 리스트의 max값을 찾을 수 있는 Collection.max 함수를 써 제일 큰 값을 찾아낸 뒤 그 값을 정답으로 리턴한다.



*/


import java.util.ArrayList;
import java.util.Collections;

public class Solution {


       public long solution(String expression) {
        long answer = 0;
        ArrayList<String> cl = new ArrayList<>();
        ArrayList<String> ar = new ArrayList<>();
        ArrayList<Long> ans = new ArrayList<>();
        String[] cal = {"-+*","+*-","+-*","*+-","-*+","*-+"};
        String str = "";
        for (int i = 0; i < expression.length(); i++) {
            if(expression.charAt(i)=='*' || expression.charAt(i)=='+' || expression.charAt(i)=='-'){
                ar.add(str);
                ar.add(expression.charAt(i)+"");
                str="";
            }else{
                str+=expression.charAt(i);
                if(i==expression.length()-1){
                    ar.add(str);
                }
            }
        }
        cl = (ArrayList<String>) ar.clone();

        for (int i = 0; i < cal.length; i++) {
            ar = (ArrayList<String>) cl.clone();
            flag(cal[i].charAt(0),ar);
            flag(cal[i].charAt(1),ar);
            flag(cal[i].charAt(2),ar);
            ans.add(Math.abs(Long.parseLong(ar.get(0))));
        }
        answer = Collections.max(ans);
        return answer;
    }

    public static ArrayList<String> flag(char a, ArrayList<String> ar) {
        int i = 0;
        if(ar.contains(a+"")==false){
            return ar;
        }

        while (true){
            if(i>=ar.size()){
                break;
            }

            if(ar.get(i).equals(a+"")){
                if(a=='*'){
                    long z = Long.parseLong(ar.get(i-1)) * Long.parseLong(ar.get(i+1));
                    ar.remove(i-1);
                    ar.remove(i-1);
                    ar.remove(i-1);
                    ar.add(i-1,Long.toString(z));
                    i--;
                }else if(a=='+'){
                    long z = Long.parseLong(ar.get(i-1)) + Long.parseLong(ar.get(i+1));
                    ar.remove(i-1);
                    ar.remove(i-1);
                    ar.remove(i-1);
                    ar.add(i-1,Long.toString(z));
                    i--;
                }else{
                    long z = Long.parseLong(ar.get(i-1)) - Long.parseLong(ar.get(i+1));
                    ar.remove(i-1);
                    ar.remove(i-1);
                    ar.remove(i-1);
                    ar.add(i-1,Long.toString(z));
                    i--;
                }
            }
            i++;
        }

        return ar;
    }


}
